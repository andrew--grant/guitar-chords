<chords-menu-w-progress>
    <div each={mi in menuItems } class='chord-button-container'>
        <!-- button and progress indicator-->
        <button id="{mi.index}" class='chord-button' onclick={chordSelected}>{mi.name}</button>
        <progress-bar shape="bar" reverse="true" id="{mi.index}" duration="10" start={doProgressStart} end={doProgressEnd} progress={doProgress}/>
    </div>
    <style>
        .chords-menu {
            margin: auto;
            text-align: center;
            font-size: 2em;
            max-width: 1000px;
            min-width: 800px;
        }
        
        .chord-button {
            background-color: #222;
            margin: 0;
            padding: .2em;
            color: #eee;
            font-size: 2em;
            border: none;
            border-radius: 4px 4px 0 0;
            outline: none;
            width: 100%;
        }
        
        .chord-button-container {
            float: left;
            padding: 0;
            overflow: hidden;
            margin: .25em;
            text-align: center;
            width: 130px;
        }
        
        .chord-button:hover {
            background-color: #c22;
            color: white;
        }
        
        .chord-button:active {
            background-color: #c22;
            color: white;
            height: 100%;
        }
        
        .chord-button-active {
            background-color: #c22;
            color: white;
            height: 100%;
        }
        
        .chord-selected {
            background-color: #c22;
        }
    </style>
    <script>
        var self = this;
        self.chordIndex = 0;
        self.selectedChord = null;
        this.menuItems = [];

        self.on('mount', function() {
            // apply default menu items filter
            self.renderMenuItems('Default');
        });

        self.on('update', function() {
            self.selectedChord = self.opts.model.chords[self.chordIndex];
        });

        chordSelected(e) {
            self.chordIndex = e.target.id;
            $('.chord-button').removeClass('chord-selected');
            $(e.target).addClass('chord-selected');
            self.opts.doselect(self.opts.model.chords[self.chordIndex]);
            // start this menu items progress bar
            var tags = self.tags['progress-bar'];
            tags[e.target.id].start();
            // todo: visuals, forward or reverse? 
            // todo: hide progress bar indicator when not needed
            // (no red strip underneath when ot being played)
            // todo: test, slideshow implications will produce work
        }

        renderMenuItems(filter) {
            var chords = null;
            if (filter) {
                chords = self.opts.model.getChordsByCategory(filter); // self.filterChords(filter);
            } else {
                // default, render all or some 'simple' or 'popular' set?
                chords = self.opts.model.chords;
            }
            // render chords
            for (var i = 0; i < chords.length; i++) {
                this.menuItems.push({
                    "name": chords[i].name, //todo: actual chord name
                    "index": i
                });
            }

            this.update();
        }

        doProgressLoaded(pb) {
            // console.log('doProgressLoaded');
            // pb.start();
        }

        doProgressStart() {
            //console.log('doProgressStart');
        }

        doProgressEnd() {
            //console.log('doProgressEnd');
        }

        doProgress() {
            //console.log('doProgress');
        }
    </script>
</chords-menu-w-progress>